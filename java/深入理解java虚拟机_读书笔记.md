

* [java内存区域与内存溢出异常（第二章）](#java内存区域与内存溢出异常第二章)  
		* [jvm运行时数据区分为两大部分](#jvm运行时数据区分为两大部分)  
		* [java.lang.OutOfMemoryError(OOM)的几种情况：](#javalangoutofmemoryerroroom的几种情况)  
		* [new对象的过程：](#new对象的过程)  
		* [对象在堆内存中的存储布局：](#对象在堆内存中的存储布局)  
		* [对象的访问定位：](#对象的访问定位)  
* [垃圾收集器与内存分配策略（第三章）](#垃圾收集器与内存分配策略第三章)  
		* [如何判断垃圾？（对象已不再被使用）：](#如何判断垃圾对象已不再被使用)  
		* [四类引用：](#四类引用)  
		* [对象回收过程：](#对象回收过程)  
		* [GC算法：](#gc算法)  
		* [如何处理跨代引用：](#如何处理跨代引用)  
		* [何时会STW：](#何时会stw)  
		* [并发的可达性分析如何解决对象消失：](#并发的可达性分析如何解决对象消失)  
		* [几种垃圾收集器：](#几种垃圾收集器)  
		* [内存分配与回收策略：](#内存分配与回收策略)  
		* [何时会发生Full GC：](#何时会发生full-gc)  
* [虚拟机性能监控、故障处理工具（第四章）](#虚拟机性能监控-故障处理工具第四章)  
		* [虚拟机命令工具](#虚拟机命令工具)  
* [虚拟机类加载机制（第七章）](#虚拟机类加载机制第七章)  
		* [类与类加载器](#类与类加载器)  
		* [双亲委派模型](#双亲委派模型)  
* [第十二章](#第十二章)  
		* [volatile的作用：](#volatile的作用)  
		* [何时应加锁以保证原子性](#何时应加锁以保证原子性)  
		* [Java内存模型下的先行发生关系（用于判断代码执行的先后顺序）：](#java内存模型下的先行发生关系用于判断代码执行的先后顺序)  
		* [java线程的状态及出现情况：](#java线程的状态及出现情况)  
* [第十三章](#第十三章)  
		* [什么是线程安全](#什么是线程安全)  
		* [线程安全的实现方法：](#线程安全的实现方法)  

# java内存区域与内存溢出异常（第二章）

### jvm运行时数据区分为两大部分

线程共享的：方法区、堆
线程私有的：虚拟机栈、本地方法栈、程序计数器

程序计数器：存储当前线程执行的字节码的行号指示器（本地方法的话则为空）

虚拟机栈：方法被执行时会创建一个栈帧用于存储(局部变量表(8中基本变量 和对象引用)、操作数栈、动态链接)方法的相关信息，方法被调用时入栈，执行完成时出栈

本地方法栈：和虚拟机栈类似，为本地方法服务。

堆：用于存放对象实例，从JDK 7开始字符串常量池被移到堆中。

方法区：方法区的主要职责是用于存放类的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。也存储常量（运行时常量池）、静态变量等数据。JDK 8中用元空间实现。

StackOverFlowError：虚拟机栈/本地方法栈深度溢出时。栈帧太大，无法分配内存时。-Xss 参数设置栈容量。

### java.lang.OutOfMemoryError(OOM)的几种情况：

1，栈（jvm栈 、native方法栈）的容量可以动态扩展但无法申请到足够内存时。

2，Java heap space：java堆中没有内存完成实例分配且无法扩展时。
解决方法：对堆快照进行分析，分析GC Roots引用链定位对象创建的位置。修改代码使得导致内存泄漏的对象能被GC，或者调大虚拟机的堆参数，-Xmx（最大值）与 -Xms（最小值）。

3，PermGen space（jdk 7中）：方法区无法满足内存分配需求时。
常见情况：有大量的类填满方法区（或者生成了大量动态类），大量JSP或动态产生JSP文件（jsp首次运行时会编译为java类）等。
相关参数：
	-XX：MaxMetaspaceSize：设置元空间最大值（默认不限制）
	-XX：MetaspaceSize：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过-XX：MaxMetaspaceSize（如果设置了的话）的情况下，适当提高该值。
	·-XX：MinMetaspaceFreeRatio：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。类似的还有-XX：Max-MetaspaceFreeRatio，用于控制最大的元空间剩余容量的百分比。

4，unable to create native thread：创建线程过多导致内存溢出。
解决方法：减少线程数量、更换64位虚拟机、减少最大堆和减少栈容量来换取更多的线程。

5，本机直接内存的分配不足时。程序中直接或者间接使用了DirectMemory（使用NIO会间接使用到）。

### new对象的过程：

1，首先检查能否在常量池中定位到一个类的符号引用，并检查这个类有没有加载、解析、初始化，如果没有就执行相应的类加载过程。
2，分配内存，（从堆中划分内存，年轻代，对象大小超过一定阈值划分在老年代。）把一块确定大小的内存块从堆中划分出来。
	多线程划分空间：1，同步处理，CAS失败重试的方式保证更新的原子性。2，不同线程划分不同的空间（本地线程分配缓冲（TLAB）（在堆中）），分配新的缓存区时同步锁定。
3，内存空间初始化为零值。
4，设置对象头中的信息。（是哪个类，如何找到类的元数据信息）
5，接着执行构造函数，即字节码中的< init >（）方法

### 对象在堆内存中的存储布局：

三部分：对象头、实例数据、对齐填充（padding）
	对象头：运行时数据，类型指针（用来确定对象是哪个类的实例）。
	实例数据：包括从父类继承下来的各个类型的字段。
	对齐填充：不是必然存在，占位符的作用，确保对象大小是8字节的整数倍。
	

### 对象的访问定位：

通过jvm栈上栈帧中的reference数据来定位堆上的对象。
	分为使用句柄和直接指针两种。
	句柄访问：reference中存储对象的句柄地址。句柄中包含对象实例数据和类型数据的地址信息。堆中划分一块内存来作为句柄池。优势：reference中存储的稳定句柄地址，对象被移动（GC时可能发生）时只用修改句柄中的实例数据指针。
	直接指针：reference中存储对象地址，堆中对象的内存布局就要放置访问类型数据的相关信息。优势：快（只用读取一次指针就能定位到对象）
	

# 垃圾收集器与内存分配策略（第三章）

### 如何判断垃圾？（对象已不再被使用）：

1，引用计数法。无法解决循环引用。java并不采用。有引用加1，引用失效减1。
2，可达性分析算法。java采用。
	java中的算法思路：从GC Roots开始向下搜索，对象不可达时证明对象是不再被使用的。
	GC Roots包含：虚拟机栈中引用的对象、本地方法栈中native方法引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、、、虚拟机内部的引用（基本类型对应的Class对象，常驻的异常对象）、同步锁（Synchronized）持有的对象、其他临时对象（只收集堆中部分区域时将关联区域的对象加入GC Roots）

### 四类引用：

强引用：类似“Object obj=new Object()”这种引用关系，GC永不回收
软引用：内存不够时才被回收。
弱引用：一旦GC就被回收。
虚引用：不影响GC，被回收时会收到通知。
	

### 对象回收过程：

1，被可达性算法判定为不可达，进行第一次标记。
2，筛选有没有必要执行finalize（）方法。
	○ 假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。
	○ 被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。
3，对象若在finalize()方法中与引用链上的对象建立关联，就被移除即将回收的集合。
4，。。。

判定类是否不再被使用的条件：（允许满足这些条件的类被回收）
	1，该类所有的实例（包括其子类的实例）都已经被回收
	2，加载该类的类加载器已经被回收
	3，该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### GC算法：

标记清除：分为“标记”和“清除”两个阶段。
缺点：1，回收大量对象时会进行大量标记和清楚的动作，效率变低。2，产生内存碎片。
标记复制：内存等分成两块，每次用一块，一块用完时，活的对象复制到另一块，原来那块空间一次清理掉。
缺点：可用内存缩小为原来一半，浪费空间。内存间复制有开销。
标记整理：先标记，然后把存活的对象向内存空间的一端移动。
缺点：移动对象开销较大。
	
java虚拟机采用分代收集法
	堆被划分为新生代和老年代，GC中需考虑跨代引用。
	

### 如何处理跨代引用：

在新生代上建立一个名为记忆集的全局数据结构，在此标记老年代中包含了跨代引用的部分，在GC时这些内存中的对象才会被加入到GC Roots进行扫描。
记忆集的一种实现方式：
卡表。形式是字节数组，数组的每个元素对应着其标识的内存区域中的一块内存块（卡页），只要卡页中有对象的字段存在跨代指针，那对应的数组元素值标识为1（成为变脏），收集垃圾时筛选出卡表中变脏的元素，能得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。
如何维护卡表：
在HotSpot虚拟机里是通过写屏障（Write Barrier）技术维护卡表状态的。引用字段赋值的前后都在写屏障的覆盖范畴内。收集器在写屏障中增加更新卡表操作，更新引用时就会更新卡表。
	

新生代Minor GC。HotSpot虚拟机上使用特殊的标记复制算法。0.8Eden ，0.1Survivor from，0.1Survivor to。如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象便将通过分配担保机制直接进入老年代（名为逃生门的安全设计）。  
老年代Major GC。  
整堆收集Full GC。  
	
	

### 何时会STW：

根节点（GC Roots）枚举时、GC过程中移动对象时会STW。  

如何停顿用户线程：
使用安全点，用户程序执行时必须执行到达安全点后才能够暂停。方法调用、循环跳转、异常跳转等具有指令序列复用功能的指令会产生安全点。
安全区域。用户线程进入Sleep状态或者Blocked状态时会首先标识自己进入安全区域，此时虚拟机发起垃圾收集就不必管这些线程，线程离开安全区域时需等待根节点枚举完成才可离开。
垃圾收集发生时如何让所有线程跑到最近的安全点：
抢先式中断：垃圾收集时中断所有用户线程，恢复不在安全点的的线程让它执行到安全点再中断。（几乎不采用）
主动式中断：垃圾收集需要中断线程时，设置一个标志位，线程执行时会轮询标志位，发现标志位为真就在最近的安全点上中断。（轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。）
为何GC中会STW（stop the world）：
根节点枚举必须在一个能保障一致性的快照中才得以进行。
GC中移动对象时如果不停止会引发错误。
	

### 并发的可达性分析如何解决对象消失：

首先介绍三色标记：白色表示对象尚未被标记，黑色表示对象已被标记且这个对象的所有引用都已被扫描，灰色表示已被标记但仍有引用未被扫描。
为避免并发时可达性分析将原本存活的对象误标记为死亡的对象（程序会发生错误），需破坏以下两个条件之一：
1. 赋值器插入了一条或多条从黑色对象到白色对象的新引用；  
2. 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。  
破坏第一个条件的方案，增量更新：当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。
破坏第二个条件的方案，原始快照：当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。
		

### 几种垃圾收集器：

Serial：单线程，会产生STW。用在新生代。标记复制算法。

ParNew：多线程，会产生STW。用在新生代。采用标记复制方法。

Paralle Scavenge：多线程，用在新生代。采用标记复制算法。可精确控制吞吐量（用户代码时间）/（用户代码+垃圾收集时间）。收集器将尽力保证内存回收花费的时间不超过用户设定值。

Serial Old：单线程，标记整理算法。用在老年代。

Parallel Old：Paralle Scavenge的老年代版。标记整理算法。

CMS：标记清除法，用在老年代。实现了让垃圾收集线程与用户线程（基本上）同时工作。无法与新生代收集器Parallel Scavenge配合使用。
	运行过分的四个步骤：
	1、初始标记：（会引发stw）标记GC Roots直接关联到的对象
	2、并发标记：从GC Roots直接关联到的对象开始遍历对象图，不需要停顿用户线程。
	3、重新标记：（会引发stw）是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（关联增量更新）。
	4、并发清除：清理删除掉标记阶段判断的已经死亡的对象，不需要移动存活对象故可以与用户线程同时并发的。
	CMS默认启动的回收线程数是（处理器核心数量+3）/4。
	需要注意：
	§ 由于CMS收集器无法处理“浮动垃圾”，有可能出现并发失败，进而导致Full GC。
	§ 需要预留足够内存空间提供给用户线程使用，若预留的内存无法满足分配新对象的需要就会出现并发失败。
	§ 产生空间碎片，可能会出现老年代还有很多剩余空间，却没有连续空间来分配给大对象，而不得不提前触发一次Full GC的情况。
	
G1：面向java堆
	

### 内存分配与回收策略：

大多数情况下对象在新生代Eden区分配，Eden区没有足够空间时Minor GC。

对象进入老年代的情形：
	1、寿命达到阈值
	2、分配担保机制，有对象无法放入survivor区（survivor空间不足导致）
	3、大对象直接进入老年代
	4、survivor空间中相同年龄所有对象大小的总和大于survivor空间的一半时，年龄大于或等于此年龄的对象就直接进入年老代。
	
发生Minor GC之前，虚拟机必须检查老年代最大可用的连续空间是否大于新生代所有对象总空间。大于则此次Minor GC安全，小于，允许担保失败 且 老年代最大连续可用空间大于历次晋升到老年代的平均大小，则尝试Minnor GC（尽管有风险）。小于或不允许冒险则就要改为进行一次Full GC。

JDK6 Update24之后改为老年代连续空间大于年轻代所有对象总空间或大于历次晋升的平均大小就Minor GC，否则就进行一次Full GC。
	

### 何时会发生Full GC：

○ 调用System.gc（）时（此命令通知系统进行垃圾回收，具体何时执行看虚拟机的调度）
○ Minor GC前检查 老年代连续内存空间的大小 小于 年轻代所有对象总和 且小于 历次晋升到老年代的平均大小时。
○ 对象需要进入老年代时发现老年代内存不足（寿命达到阈值、survivor区空间不足放不下、survivor中相同年龄x对象大小的总和大于survivor空间的一半时年龄大于等于x的对象都进入老年代、大对象直接进入）
○ 元空间内存不足时。（有大量动态类或Jsp界面）

# 虚拟机性能监控、故障处理工具（第四章）

### 虚拟机命令工具

jps ：可以列出正在运行的虚拟机进程。
	jps -l ，显示进程号及main函数所在类名称
jstat：监视虚拟机各种运行状态信息的命令行工具，可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据。
	jstat -gcutil pid，可查询堆内存各部分占用情况及各类GC次数等信息。
jinfo：实时查看和调整虚拟机各项参数。
jmap：用于生成堆转储快照。（类似：-XX：+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在内存溢出异常出现之后自动生成堆转储快照文件，通过-XX：+HeapDumpOnCtrlBreak参数则可以使用[ Ctrl ]+[ Break ]键让虚拟机生成堆转储快照文件，又或者在Linux系统下通过Kill-3命令发送进程退出信号“恐吓”一下虚拟机，也能顺利拿到堆转储快照。）
jhat：分析jmap生成的堆转储快照。
jstack：生成虚拟机当前时刻的线程快照。
	jstack -l pid，
		
可视化工具：请参见原书。


# 虚拟机类加载机制（第七章）

类的整个生命周期有加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。

何时对类进行初始化：
	1，new对象时，操作类的静态字段，调用类的静态方法时 如果没有初始化会先进行初始化。
	2，对类型进行反射调用的时候， 如果没有初始化会先进行初始化。
	3，初始化类时发现其父类还没初始化，就先初始化其父类。
	4，虚拟机启动时会先初始化主类（main（）方法所在的类）。
	5，当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
	6，当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。
	

### 类与类加载器

对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。
类加载器：
	Bootstrap Class Loader（启动类加载器）
	Extension Class Loader（扩展类加载器）
	Application Class Loader（应用程序类加载器）

### 双亲委派模型

工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。



# 第十二章

### volatile的作用：

三点：保证可见性、但不保证原子性、禁止指令重排序

### 何时应加锁以保证原子性

在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized、java.util.concurrent中的锁或原子类）来保证原子性：
1. 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。  
2. 变量不需要与其他的状态变量共同参与不变约束。  

synchronized和final两个关键字能实现可见性。

### Java内存模型下的先行发生关系（用于判断代码执行的先后顺序）：

程序次序规则（Program Order Rule）：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。

·管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。

·volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。·

线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。

·线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。

·线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生。

·对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。

·传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。
	

### java线程的状态及出现情况：

·新建（New）：创建后尚未启动的线程处于这种状态。
·运行（Runnable）：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。
·无限期等待（Waiting）：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态：
	■没有设置Timeout参数的Object::wait()方法；
	■没有设置Timeout参数的Thread::join()方法；
	■LockSupport::park()方法。
·限期等待（Timed Waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：
	■Thread::sleep()方法；
	■设置了Timeout参数的Object::wait()方法；
	■设置了Timeout参数的Thread::join()方法；
	■LockSupport::parkNanos()方法；
	■LockSupport::parkUntil()方法。
·阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。
·结束（Terminated）：已终止线程的线程状态，线程已经结束执行。

# 第十三章

### 什么是线程安全

线程安全：“当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。”

### 线程安全的实现方法：

1.互斥同步。临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是常见的互斥实现方式。

在Java里面，最基本的互斥同步手段就是synchronized关键字，这是一种块结构（Block Structured）的同步语法。synchronized关键字经过Javac编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。

基于Lock接口实现互斥同步手段。lock的额外功能，主要有：等待可中断、可实现公平锁及锁可以绑定多个条件。

2.非阻塞同步。Unsafe类中的CAS操作（可能产生ABA问题）。
	ABA问题的解决方法：时间戳 或者 版本号。
