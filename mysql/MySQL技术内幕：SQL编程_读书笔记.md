- [第二章 数据类型](#第二章-数据类型)
  - [字符类型](#字符类型)
    - [BLOB和TEXT](#blob和text)
      - [BLOB的存储方式](#blob的存储方式)
- [第九章 索引](#第九章-索引)
  - [introduce](#introduce)
  - [缓冲池](#缓冲池)
  - [关于机械硬盘（待整理）](#关于机械硬盘待整理)
  - [B+树](#b树)
    - [B+树的相关操作](#b树的相关操作)
    - [B+树索引](#b树索引)
      - [InnoDB中的两种索引](#innodb中的两种索引)
      - [MyISAM中](#myisam中)
      - [判断索引的效率。](#判断索引的效率)
      - [联合索引](#联合索引)
        - [联合索引何时起作用](#联合索引何时起作用)
      - [覆盖索引](#覆盖索引)
      - [Multi-Range Read (MRR)](#multi-range-read-mrr)
      - [Index Condition Pushdown](#index-condition-pushdown)
  - [T树索引](#t树索引)
  - [哈希索引](#哈希索引)

书中的示例一共用到三个数据库文件：一个是employees数据库，该数据库是MySQL数据库官方提供的示例数据库，主要用来模拟公司员工的数据，用户可以通过官网下载[http://dev.mysql.com/doc/index-other.html](http://dev.mysql.com/doc/index-other.html)；另一个是dbt3数据库，是通过Database Test Suite程序生成的，该数据库较大，主要用来展示一些复杂的查询；还有一个tpcc数据库，是一个模拟TPC-C测试的数据库，用户可以从[http://code.google.com/p/david-mysql-tools/](http://code.google.com/p/david-mysql-tools/)下载。  


# 第二章 数据类型  
## 字符类型  
### BLOB和TEXT  
BLOB是用来存储二进制大数据类型的，根据存储长度的不同可分为4种：TINYBLOB(2<sup>8</sup>字节)，BLOB（2<sup>16</sup>），MEDIUMBLOB（2<sup>24</sup>），LONGBLOB（2<sup>32</sup>），TEXT类型类似。  

#### BLOB的存储方式  
数据页由数据行组成，每行数据由列组成，列类型为BLOB时，InnoDB只存储前20字节，而该列的完整数据则存放在BLOB的行溢出页中。  

notice：  
1. 在BLOB和TEXT类型的列上创建索引时，必须制定索引前缀的长度。  
2. BLOB和TEXT类型的列不能有默认值。  
3. 在排序时只使用列的前max_sort_length（默认1024，客户端运行时可更改）个字节。  
4. 在有些存储引擎内部，比如InnoDB存储引擎，会将大VARCHAR类型字符串（如VARCHAR（65530））自动转化为TEXT或BLOB类型

# 第九章 索引  

## introduce
说明：更多索引内容参见[MySQL技术内幕：InnoDB存储引擎_读书笔记.md](MySQL技术内幕：InnoDB存储引擎_读书笔记.md#introduce)  

Tip: 可以在SQL语句的表名后接 FORCE INDEX(idx_a) 来强制优化器使用索引idx_a。  


## 缓冲池  
磁盘的速度远慢于内存，因此基于磁盘的数据库系统一般都有缓冲池，即一块内存区域，其作用是将从磁盘上读取的指定大小数据—称为页（或块），放入缓冲池。当再次读取时，数据库首先判断该页是否在缓冲池中，如果在则直接读取缓冲池中的页，如果不在则读取磁盘上的页。对于写操作，数据库将页读入缓冲池，然后在缓冲池中对页进行修改，修改完成后的页一般被异步地写入磁盘上。   
MySQL中，对于MyISAM存储引擎来说，变量key_buffer_size决定了缓冲池的大小。对于InnoDB存储引擎来说，变量innodb_buffer_pool_size决定了缓冲池的大小。  
缓冲池对数据库性能影响较大，当数据库的数据全部被缓存在缓冲池中，这时数据库的性能是最优的。
但实际生产环境中，数据库往往大于内存，因此不可避免地存在磁盘的读取操作。  

## 关于机械硬盘（待整理）  
传统机械硬盘由磁头（head）、磁道（track）、扇区（sector）、柱面（cylinder）组成。读取时需要通过磁头的移动来定位数据，这个时间称为寻道时间（seek time）。15000转SAS传统的机械硬盘的平均寻道时间为2.58ms。传统的机械硬盘的特性决定了顺序读取要远快于离散读取。  
固态硬盘内部由闪存（flashmemory）组成。闪存是一个完全的电子设备，没有任何的读写磁头等移动部件，因此固态硬盘有着较低的访问延时。固态硬盘的访问延时一般小于0.1 ms左右，随机读取可达4000 IOPS甚至更高。即使是固态硬盘，顺序读取还是要快于随机读取。  

## B+树  
B+树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点，各叶子节点通过指针进行链接。  

### B+树的相关操作  
注：
Leaf Page是叶子节点中的关键字页，Index Page是中间节点中的关键字页。
B+树插入的三种情况  
| Leaf Page是否已满 | Index Page是否已满 | 操作 |
| :-: | :-: | :- |
| No | No | 直接插入|
| Yes | No | 1. 拆分Leaf Page<br>2. 将中间的节点放入到Index Page中<br>3. 小于中间结点的记录放左边<br>4. 大于等于中间结点的记录放右边
| Yes | Yes | 1. 拆分Leaf Page<br>2. 小于中间结点的记录放左边<br>3. 大于等于中间结点的记录放右边<br>4. 将将中间的节点放入到Index Page中<br>5. 拆分Index Page<br>6. 小于中间节点的记录放左边<br>7. 大于中间节点的记录放右边<br>8. 中间节点放入上一层Index Page
|  |  |  |  

B+树的旋转  
旋转发生在Leaf Page已经满而其左右兄弟节点没有满的情况下。这时B+树并不会急于进行拆分页的操作，而是将记录移到所在页的兄弟节点上。转移之后维护Index Page中的值。  

B+树的删除操作  
B+树使用填充因子（fill factor）来控制树的删除变化，填充因子可设的最小值是50%。
| 叶节点小于填充因子 | 中间节点小于填充因子 | 操作 |
| :-: | :-: | :- |
| No | No | 直接将记录从叶节点删除，如果该节点还是Index Page的关键字，用该节点的右节点代替|
| Yes | No | 合并叶子节点和它的兄弟节点，同时更新Index Page
| Yes | Yes | 1. 合并叶子节点和它的兄弟节点<br>2. 更新Index Page<br>3. 合并Index Page和它的兄弟节点
|  |  |  |  

### B+树索引  
#### InnoDB中的两种索引
高扇出性：非叶子节点中能保存的指针数量多。  
在InnoDB存储引擎中，每个页的大小为16KB。B+索引在数据库中有一个特点是高扇出性。在数据库中，B+树的高度一般都在2～4层，这意味着查找某一键值最多只需要2到4次IO操作，这还不错。因为现在一般的磁盘每秒至少可以做100次IO操作，2～4次的IO操作意味着查询时间只需0.02～0.04秒。  

InnoDB存储引擎是索引组织表（Index Organized Table，IOT），也就是说数据文件本身就是按照B+树方式存放数据的。其中，B+树的键值为主键，若在建立时没有显式地指定主键，则InnoDB存储引擎会自动创建一个6字节的列作为主键。因此在InnoDB存储引擎中，可以将B+树索引分为聚集索引（clustered index）和辅助索引（secondary index）。无论是何种索引，每个页的大小都为16KB，且不能更改。  

聚集索引是根据主键创建的一棵B+树，聚集索引的叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。  
辅助索引是根据索引键创建的一棵B+树，与聚集索引不同的是，其叶子节点仅存放索引键值，以及该索引键值指向的主键。如果通过辅助索引来查找数据，那么当找到辅助索引的叶子节点后，很有可能还需要根据主键值查找聚集索引来得到数据，这种查找方式又被称为书签查找（bookmark lookup）。因为辅助索引不包含行记录的所有数据，这就意味着每页可以存放更多的键值，因此其高度一般都要小于聚集索引。  

#### MyISAM中  
MyISAM存储引擎中，所有的行数据都存放于MYD文件中，其B+树索引都是辅助索引，存放于MYI文件中。PRIMARY KEY索引和其他索引不同之处在于其必须是唯一的，并且不可为NULL值。其索引页的大小默认为1KB，不可以调整。因为没有聚集索引，其索引叶节点存放的键值不是主键值，而是在MYD文件中的物理位置。  

#### 判断索引的效率。
为什么样的主键建立索引更有价值？  

取值范围小、重复度高的字段（称为低选择性）没有必要建索引。若某个字段取值范围广、几乎没有重复（高选择性）的字段，适合建立B+树索引。  

怎样查看索引是否是高选择性的呢？  
可以通过SHOW INDEX语句中的Cardinality列来观察。Cardinality/n_rows_in_table应尽可能接近1。n_rows_in_table（表中的总行数）。  
Cardinality（基数）从8页表中估计出来的表中索引列中不同记录的数量。计算方法如下：
取得B+树索引中叶节点的数量，即为A。  
随机取B+树索引中的8个叶节点。统计每个页不同记录的个数，即为P1，P2，...，P8。  
根据采样信息给出Cardinality的预估值：Cardinality=（P1+P2+...+P8）*A/8。  

#### 联合索引  
从本质上来说，联合索引还是一棵B+树，不同的是联合索引的键值数量不是1，而是大于等于2。  

##### 联合索引何时起作用  
例子：某表有联合索引idx_a_b_c，索引idx_a。  
| 条件   | 索引使用情况 |
|:-     |:-            |
| a=xx and b=xx   | 可以使用到idx_a_b_c |
| a=xx and c=xx   | 可以使用到索引（具体哪个看explain） |
| b=xx            | 不会使用到索引，会全表扫描 |
| a=xx ORDER BY b | 可以使用到idx_a_b_c<br>这种情况下不必using filesort |
| | |

判定原则：联合索引本质上是一颗B+树，树中关键字按照 a b c 排序，只要满足符合查找条件的记录，可以通过B+树限定在某个小于全表的范围内，就会使用到联合索引，限定的范围越小，效率就越高。若不能通过B+树限定在某个小于全表的范围，就会全表扫描，索引失效。  

#### 覆盖索引  
使用到覆盖索引的条件是：  
1. 查找条件可以用到某索引idx。  
2. 索引idx索引的列含有查找的所有列。  
explain计划中的extra项有using index即标识用到了覆盖索引。  
InnoDB存储引擎支持覆盖索引，即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。  
使用覆盖索引的好处是可以减少大量的IO操作，原因是辅助索引不包含整行记录的所有信息，其大小要远小于聚集索引。  
对于联合索引idx_a_b，通常查询条件仅限定b列时不会使用到索引，但对于统计操作，如果是覆盖索引的，则优化器会用到覆盖索引。  

索引失效的一种情况：  
查询整行信息时，访问的数据占整个表中数据的很大一部分时（通常20%左右），会由于无法覆盖索引而使用聚集索引（即进行全表扫描）查找数据。这是由于机械硬盘的顺序读取速度大于随机读取，若使用辅助索引 在查找到指定数据后还需要进行一次书签访问来查找整行数据，变为了磁盘上的离散读取操作。  

#### Multi-Range Read (MRR)  
mysql5.6开始支持。  
MRR优化的目的就是减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，可为IO-bound类型的SQL查询语句带来性能的极大提升。MRR优化适用于range、ref和eq_ref类型的查询。  

对于InnoDB和MyISAM存储引擎的范围查询和联接查询，MRR的工作方式如下：  
1. 将查询得到的辅助索引键值存放于一个缓存中，这时缓存中的数据是根据辅助索引键值排序的。  
2. 将缓存中的键值根据RowID进行排序。  
3. 根据RowID的排序顺序来访问实际的数据文件。  

MRR优化有以下几个好处：  
1. 使得数据访问变得较为顺序。在查询辅助索引时，先对得到的查询结果按照主键进行排序，并按照主键排列的顺序进行书签查找。  
2. 减少缓冲池中页被替换的次数。  
3. 批量处理对键值的查询操作。  

将MRR优化设置为总是开启：  
SET @@optimizer_switch='mrr=on,mrr_cost_based=off';

参数read_rnd_buffer_size用来控制键值的缓冲区大小，当大于该参数值时，执行器根据RowID对已经缓存的数据进行排序，并通过RowID来取得行数据。该值默认为256KB。  

#### Index Condition Pushdown  
mysql5.6开始支持。  
不支持ICP：当进行索引查询时，首先根据索引来查找记录，然后再根据WHERE条件来过滤记录。  
支持ICP：MySQL数据库会在取出索引的同时，判断是否可以进行WHERE条件的过滤（即将WHERE的部分过滤操作放在了存储引擎层）。减少上层SQL层对于记录的索取（fetch）。  

## T树索引  
NDB Cluster内存存储引擎，在使用它时可将其视为内存数据库。内存数据库中，一般使用T树（T-Tree）作为其索引的数据结构。  
NDB Cluster存储引擎中的Order Index（普通索引），使用的就是T树结构。  
T树的好处是节点不存放数据，只存放指针，这样能减少对内存的使用，同时T树也是一棵平衡二叉树，以此保证查找的性能。  
T树节点由3个指针、一个有序数组（array），以及控制信息组成。3个指针分别为指向父节点和左右子树的指针。有序数组保存的是数据指针。  
T树中，对于每个内部节点，存在一个相对应的叶节点或半叶节点存放内部节点的最小值，该值称为最大下界（greatest lowerbound），也存在相对应的叶节点或半叶节点用于存放内部节点的最大值，该值称为最小上界（least upper bound）。  

树的查找和二叉查找树类似，其查找算法为：  
1. 从根节点（root）开始查找，比较节点中最大值和最小值。如果查找的值在边界内，则用二叉法查找T树中的数组。  
2. 若查找的值比根节点的最小值小，则递归查找左子树。  
3. 若查找的值比根节点的最大值大，则递归查找右子树。  
4. 若不存在该值，返回为NULL。  

T树的插入删除旋转操作参见原书9.9部分。  

## 哈希索引  
InnoDB存储引擎使用散列算法来对字典进行查找，其冲突机制采用链表方式，散列函数采用除法散列方式。  

InnoDB存储引擎对于页是怎么进行查找：  
InnoDB存储引擎的表空间都有一个space号，我们要查找的应该是某个表空间的某个连续16KB的页，即偏移量offset。InnoDB存储引擎将space左移20位，然后加上这个space和offset，即关键字K=space << 20 + space +offset，然后通过除法散列到各个槽中去。  

自适应哈希索引采用之前讨论的散列表的方式实现。不同的是，自适应哈希索引仅是数据库自身创建并使用的，DBA本身并不能对其进行干预。自适应哈希索引经散列函数映射到一个散列表中，因此对于字典类型的查找非常快速，例如SELECT ＊ FROM TABLE WHERE index_col='xxx'，但是对于范围查找就无能为力了。通过命令SHOW ENGINE INNODB STATUS可以看到当前自适应哈希索引的使用状况。

[a](#aaa)
