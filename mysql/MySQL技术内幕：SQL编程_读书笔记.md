- [第二章 数据类型](#第二章-数据类型)
  - [类型](#类型)
    - [Unsigned](#unsigned)
    - [Zerofill](#zerofill)
    - [SQL MODE](#sql-mode)
  - [日期和时间](#日期和时间)
    - [相关函数](#相关函数)
  - [数字类型](#数字类型)
    - [整型](#整型)
    - [浮点型](#浮点型)
    - [高精度](#高精度)
    - [位类型](#位类型)
  - [字符类型](#字符类型)
    - [排序规则](#排序规则)
    - [CHAR和VARCHAR](#char和varchar)
    - [BINARY和VARBINARY](#binary和varbinary)
    - [BLOB和TEXT](#blob和text)
      - [BLOB的存储方式](#blob的存储方式)
    - [ENUM和SET类型](#enum和set类型)
- [第九章 索引](#第九章-索引)
  - [introduce](#introduce)
  - [缓冲池](#缓冲池)
  - [关于机械硬盘（待整理）](#关于机械硬盘待整理)
  - [B+树](#b树)
    - [B+树的相关操作](#b树的相关操作)
    - [B+树索引](#b树索引)
      - [InnoDB中的两种索引](#innodb中的两种索引)
      - [MyISAM中](#myisam中)
      - [判断索引的效率。](#判断索引的效率)
      - [联合索引](#联合索引)
        - [联合索引何时起作用](#联合索引何时起作用)
      - [覆盖索引](#覆盖索引)
      - [Multi-Range Read (MRR)](#multi-range-read-mrr)
      - [Index Condition Pushdown](#index-condition-pushdown)
  - [T树索引](#t树索引)
  - [哈希索引](#哈希索引)

书中的示例一共用到三个数据库文件：一个是employees数据库，该数据库是MySQL数据库官方提供的示例数据库，主要用来模拟公司员工的数据，用户可以通过官网下载[http://dev.mysql.com/doc/index-other.html](http://dev.mysql.com/doc/index-other.html)；另一个是dbt3数据库，是通过Database Test Suite程序生成的，该数据库较大，主要用来展示一些复杂的查询；还有一个tpcc数据库，是一个模拟TPC-C测试的数据库，用户可以从[http://code.google.com/p/david-mysql-tools/](http://code.google.com/p/david-mysql-tools/)下载。  


# 第二章 数据类型  

## 类型  
### Unsigned  
UNSIGNED属性就是将数字类型无符号化。尽量不要使用UNSIGNED，因为可能会带来一些意想不到的效果，比如1-2时可能会得到4294967295。  
### Zerofill  
int(4)：表示不足宽度时会填充0，但不影响实际的存储内容。  
### SQL MODE  
STRICT_TRANS_TABLES：在该模式下，如果一个值不能插入到一个事务表（例如表的存储引擎为InnoDB）中，则中断当前的操作不影响非事务表（例如表的存储引擎为MyISAM）。  
ALLOW_INVALID_DATES：该选项并不完全对日期的合法性进行检查，只检查月份是否在1～12之间，日期是否在1～31之间。该模式仅对DATE和DATETIME类型有效，而对TIMESTAMP无效，因为TIMESTAMP总是要求一个合法的输入。  
ANSI_QUOTES：启用ANSI_QUOTES后，不能用双引号来引用字符串，因为它将被解释为识别符。  
ERROR_FOR_DIVISION_BY_ZERO：在INSERT或UPDATE过程中，如果数据被零除（或MOD（X，0）），则产生错误（否则为警告）。如果未给出该模式，那么数据被零除时MySQL返回NULL。如果用到INSERT IGNORE或UPDATEIGNORE中，MySQL生成被零除警告，但操作结果为NULL。  
HIGH_NOT_PRECEDENCE NOT：操作符的优先顺序是表达式。例如，NOT aBETWEEN b AND c被解释为NOT（a BETWEEN b AND c），在一些旧版本MySQL中， 前面的表达式被解释为（NOT a）BETWEEN b AND c。启用HIGH_NOT_PRECEDENCE SQL模式，可以获得以前旧版本的更高优先级的结果。（提高not运算符的优先级）  
PAD_CHAR_TO_FULL_LENGTH：对于CHAR类型字段，不要截断空洞数据。空洞数据就是自动填充值为0x20的数据。  

## 日期和时间  
| 类型 | 空间（字节） |   
| :-: | :-: |  
|datetime|8|  
|date|3|  
|timestamp|4|  
|year|1|  
|time|3|  

datetime，存储年月日时分秒，可以表达的日期范围为“1000-01-0100：00：00”到“9999-12-31 23：59：59”。  
date，日期范围为“1000-01-01”到“9999-12-31”。  
timestamp，显示的范围为“1970-01-0100:00:00”UTC到“2038-01-19 03:14:07”UTC。其实际存储的内容为“1970-01-0100:00:00”到当前时间的毫秒数。可指定默认值，可以设置为执行UPDATE时更新为当前时间（ON UPDATE CURRENT_TIMESTAMP，没有实际更新内容时不会修改）。  
year，类型占用1字节，并且在定义时可以指定显示的宽度为YEAR（4）或YEAR（2），YEAR（4），其显示年份的范围为1901～2155；对于YEAR（2），其显示年份的范围为1970～2070。在YEAR（2）的设置下，00～69代表2000～2069年。  
time，显示的范围为“-838：59：59”～“838：59：59”。TIME类型不仅可以用来保存一天中的时间，也可以用来保存时间间隔。  

### 相关函数  
NOW、CURRENT_TIMESTAMP和SYSDATE均返回当前时间，前两者相同均返回执行此sql语句的时间，SYSDATE返回执行到它时的时间。NOW（）函数根据使用方式可以返回时间，也可以返回一个数字。   

## 数字类型  
### 整型  
### 浮点型  
MySQL数据库支持两种浮点类型：单精度的FLOAT类型及双精度的DOUBLEPRECISION类型。这两种类型都是非精确的类型，经过一些操作后并不能保证运算的正确性。  
### 高精度  
DECIMAL和NUMERIC类型在MySQL中被视为相同的类型，用于保存必须为确切精度的值。
salary DECIMAL(5,2)  
在上述例子中，5是精度，2是标度。精度表示保存值的主要位数，标度表示小数点后面可以保存的位数。   
### 位类型  
即BIT数据类型可用来保存位字段的值。BIT（M）类型表示允许存储M位数值，M范围为1到64，占用的空间为（M+7）/8字节。左端填0



## 字符类型  
utf8（utf8mb3）、utf8mb4，utf8mb3最大占用3个字节空间，后者最大占用4字节。对BMP（Basic Multilingual Plane）字符的存储，utf8mb3和utf8mb4两者是完全一样的，区别只是utf8mb4对扩展字符的支持。  
MySQL支持为各列设置不同字符集。  

对于Unicode编码的字符集，强烈建议将所有的CHAR字段设置为VARCHAR字段，因为对于CHAR字段，数据库会保存最大可能的字节数。例如，对于CHAR（30），数据库可能存储90字节的数据。  
### 排序规则  
utf8字符集默认的排序规则是utf8_general_ci。之前介绍过_ci结尾表示大小写不敏感。  
utf8_bin是按二进制排序，区分大小写。  
排序规则会影响索引。  

### CHAR和VARCHAR  
CHAR（N）用来保存固定长度的字符串，VARCHAR（N）用来保存变长字符类型。对于CHAR类型，N的范围为0～255，对于VARCHAR类型，N的范围为0～65535。CHAR（N）和VARCHAR（N）中的N都代表字符长度，而非字节长度。  
对于CHAR类型的字符串，MySQL数据库会自动对存储列的右边进行填充（RightPadded）操作，直到字符串达到指定的长度N。  
CHAR适合存储很短的字符串，或者所有值都接近同一个长度。例如密码md5。  

VARCHAR类型存储变长字段的字符类型，与CHAR类型不同的是，其存储时需要在前缀长度列表加上实际存储的字符长度，该字符占用1～2字节的空间。当存储的字符串长度小于255字节时，其需要1字节的空间，当大于255字节时，需要2字节的空间。对于有些多字节的字符集类型，其CHAR和VARCHAR在存储方法上是一样的，同样需要为长度列表加上字符串的值。  
VARCHAR适合存储长度不定的内容，较char更节省空间，因其存储变长所以update时会分裂页导致内存碎片。适合存储不常常更新的内容。  

### BINARY和VARBINARY  
BINARY和VARBINARY与前面介绍的CHAR和VARCHAR类型有点类似，BINARY和VARBINARY没有字符集的概念，对其排序和比较都是按照二进制值进行对比。  


### BLOB和TEXT  
BLOB是用来存储二进制大数据类型的，根据存储长度的不同可分为4种：TINYBLOB(2<sup>8</sup>字节)，BLOB（2<sup>16</sup>），MEDIUMBLOB（2<sup>24</sup>），LONGBLOB（2<sup>32</sup>），TEXT类型类似。  

#### BLOB的存储方式  
数据页由数据行组成，每行数据由列组成，列类型为BLOB时，InnoDB只存储前20字节，而该列的完整数据则存放在BLOB的行溢出页中。  

notice：  
1. 在BLOB和TEXT类型的列上创建索引时，必须制定索引前缀的长度。  
2. BLOB和TEXT类型的列不能有默认值。  
3. 在排序时只使用列的前max_sort_length（默认1024，客户端运行时可更改）个字节。  
4. 在有些存储引擎内部，比如InnoDB存储引擎，会将大VARCHAR类型字符串（如VARCHAR（65530））自动转化为TEXT或BLOB类型  
 
### ENUM和SET类型  
ENUM和SET类型都是集合类型，不同的是ENUM类型最多可枚举65536个元素，而SET类型最多枚举64个元素。  
MySQL不支持传统的CHECK约束，因此通过ENUM和SET类型并结合SQL_MODE可以解决一部分问题。如下：  
sex ENUM('male','female')
SET SQL_MODE='strict_trans_tables';
若插入不在集合中的值时会报错。  

# 第九章 索引  

## introduce
说明：更多索引内容参见[MySQL技术内幕：InnoDB存储引擎_读书笔记.md](MySQL技术内幕：InnoDB存储引擎_读书笔记.md#introduce)  

Tip: 可以在SQL语句的表名后接 FORCE INDEX(idx_a) 来强制优化器使用索引idx_a。  


## 缓冲池  
磁盘的速度远慢于内存，因此基于磁盘的数据库系统一般都有缓冲池，即一块内存区域，其作用是将从磁盘上读取的指定大小数据—称为页（或块），放入缓冲池。当再次读取时，数据库首先判断该页是否在缓冲池中，如果在则直接读取缓冲池中的页，如果不在则读取磁盘上的页。对于写操作，数据库将页读入缓冲池，然后在缓冲池中对页进行修改，修改完成后的页一般被异步地写入磁盘上。   
MySQL中，对于MyISAM存储引擎来说，变量key_buffer_size决定了缓冲池的大小。对于InnoDB存储引擎来说，变量innodb_buffer_pool_size决定了缓冲池的大小。  
缓冲池对数据库性能影响较大，当数据库的数据全部被缓存在缓冲池中，这时数据库的性能是最优的。
但实际生产环境中，数据库往往大于内存，因此不可避免地存在磁盘的读取操作。  

## 关于机械硬盘（待整理）  
传统机械硬盘由磁头（head）、磁道（track）、扇区（sector）、柱面（cylinder）组成。读取时需要通过磁头的移动来定位数据，这个时间称为寻道时间（seek time）。15000转SAS传统的机械硬盘的平均寻道时间为2.58ms。传统的机械硬盘的特性决定了顺序读取要远快于离散读取。  
固态硬盘内部由闪存（flashmemory）组成。闪存是一个完全的电子设备，没有任何的读写磁头等移动部件，因此固态硬盘有着较低的访问延时。固态硬盘的访问延时一般小于0.1 ms左右，随机读取可达4000 IOPS甚至更高。即使是固态硬盘，顺序读取还是要快于随机读取。  

## B+树  
B+树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点，各叶子节点通过指针进行链接。  

### B+树的相关操作  
注：
Leaf Page是叶子节点中的关键字页，Index Page是中间节点中的关键字页。
B+树插入的三种情况  
| Leaf Page是否已满 | Index Page是否已满 | 操作 |
| :-: | :-: | :- |
| No | No | 直接插入|
| Yes | No | 1. 拆分Leaf Page<br>2. 将中间的节点放入到Index Page中<br>3. 小于中间结点的记录放左边<br>4. 大于等于中间结点的记录放右边
| Yes | Yes | 1. 拆分Leaf Page<br>2. 小于中间结点的记录放左边<br>3. 大于等于中间结点的记录放右边<br>4. 将将中间的节点放入到Index Page中<br>5. 拆分Index Page<br>6. 小于中间节点的记录放左边<br>7. 大于中间节点的记录放右边<br>8. 中间节点放入上一层Index Page
|  |  |  |  

B+树的旋转  
旋转发生在Leaf Page已经满而其左右兄弟节点没有满的情况下。这时B+树并不会急于进行拆分页的操作，而是将记录移到所在页的兄弟节点上。转移之后维护Index Page中的值。  

B+树的删除操作  
B+树使用填充因子（fill factor）来控制树的删除变化，填充因子可设的最小值是50%。
| 叶节点小于填充因子 | 中间节点小于填充因子 | 操作 |
| :-: | :-: | :- |
| No | No | 直接将记录从叶节点删除，如果该节点还是Index Page的关键字，用该节点的右节点代替|
| Yes | No | 合并叶子节点和它的兄弟节点，同时更新Index Page
| Yes | Yes | 1. 合并叶子节点和它的兄弟节点<br>2. 更新Index Page<br>3. 合并Index Page和它的兄弟节点
|  |  |  |  

### B+树索引  
#### InnoDB中的两种索引
高扇出性：非叶子节点中能保存的指针数量多。  
在InnoDB存储引擎中，每个页的大小为16KB。B+索引在数据库中有一个特点是高扇出性。在数据库中，B+树的高度一般都在2～4层，这意味着查找某一键值最多只需要2到4次IO操作，这还不错。因为现在一般的磁盘每秒至少可以做100次IO操作，2～4次的IO操作意味着查询时间只需0.02～0.04秒。  

InnoDB存储引擎是索引组织表（Index Organized Table，IOT），也就是说数据文件本身就是按照B+树方式存放数据的。其中，B+树的键值为主键，若在建立时没有显式地指定主键，则InnoDB存储引擎会自动创建一个6字节的列作为主键。因此在InnoDB存储引擎中，可以将B+树索引分为聚集索引（clustered index）和辅助索引（secondary index）。无论是何种索引，每个页的大小都为16KB，且不能更改。  

聚集索引是根据主键创建的一棵B+树，聚集索引的叶子节点中存放的即为整张表的行记录数据，也将聚集索引的叶子节点称为数据页。  
辅助索引是根据索引键创建的一棵B+树，与聚集索引不同的是，其叶子节点仅存放索引键值，以及该索引键值指向的主键。如果通过辅助索引来查找数据，那么当找到辅助索引的叶子节点后，很有可能还需要根据主键值查找聚集索引来得到数据，这种查找方式又被称为书签查找（bookmark lookup）。因为辅助索引不包含行记录的所有数据，这就意味着每页可以存放更多的键值，因此其高度一般都要小于聚集索引。  

#### MyISAM中  
MyISAM存储引擎中，所有的行数据都存放于MYD文件中，其B+树索引都是辅助索引，存放于MYI文件中。PRIMARY KEY索引和其他索引不同之处在于其必须是唯一的，并且不可为NULL值。其索引页的大小默认为1KB，不可以调整。因为没有聚集索引，其索引叶节点存放的键值不是主键值，而是在MYD文件中的物理位置。  

#### 判断索引的效率。
为什么样的主键建立索引更有价值？  

取值范围小、重复度高的字段（称为低选择性）没有必要建索引。若某个字段取值范围广、几乎没有重复（高选择性）的字段，适合建立B+树索引。  

怎样查看索引是否是高选择性的呢？  
可以通过SHOW INDEX语句中的Cardinality列来观察。Cardinality/n_rows_in_table应尽可能接近1。n_rows_in_table（表中的总行数）。  
Cardinality（基数）从8页表中估计出来的表中索引列中不同记录的数量。计算方法如下：
取得B+树索引中叶节点的数量，即为A。  
随机取B+树索引中的8个叶节点。统计每个页不同记录的个数，即为P1，P2，...，P8。  
根据采样信息给出Cardinality的预估值：Cardinality=（P1+P2+...+P8）*A/8。  

#### 联合索引  
从本质上来说，联合索引还是一棵B+树，不同的是联合索引的键值数量不是1，而是大于等于2。  

##### 联合索引何时起作用  
例子：某表有联合索引idx_a_b_c，索引idx_a。  
| 条件   | 索引使用情况 |
|:-     |:-            |
| a=xx and b=xx   | 可以使用到idx_a_b_c |
| a=xx and c=xx   | 可以使用到索引（具体哪个看explain） |
| b=xx            | 不会使用到索引，会全表扫描 |
| a=xx ORDER BY b | 可以使用到idx_a_b_c<br>这种情况下不必using filesort |
| | |

判定原则：联合索引本质上是一颗B+树，树中关键字按照 a b c 排序，只要满足符合查找条件的记录，可以通过B+树限定在某个小于全表的范围内，就会使用到联合索引，限定的范围越小，效率就越高。若不能通过B+树限定在某个小于全表的范围，就会全表扫描，索引失效。  

#### 覆盖索引  
使用到覆盖索引的条件是：  
1. 查找条件可以用到某索引idx。  
2. 索引idx索引的列含有查找的所有列。  
explain计划中的extra项有using index即标识用到了覆盖索引。  
InnoDB存储引擎支持覆盖索引，即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。  
使用覆盖索引的好处是可以减少大量的IO操作，原因是辅助索引不包含整行记录的所有信息，其大小要远小于聚集索引。  
对于联合索引idx_a_b，通常查询条件仅限定b列时不会使用到索引，但对于统计操作，如果是覆盖索引的，则优化器会用到覆盖索引。  

索引失效的一种情况：  
查询整行信息时，访问的数据占整个表中数据的很大一部分时（通常20%左右），会由于无法覆盖索引而使用聚集索引（即进行全表扫描）查找数据。这是由于机械硬盘的顺序读取速度大于随机读取，若使用辅助索引 在查找到指定数据后还需要进行一次书签访问来查找整行数据，变为了磁盘上的离散读取操作。  

#### Multi-Range Read (MRR)  
mysql5.6开始支持。  
MRR优化的目的就是减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，可为IO-bound类型的SQL查询语句带来性能的极大提升。MRR优化适用于range、ref和eq_ref类型的查询。  

对于InnoDB和MyISAM存储引擎的范围查询和联接查询，MRR的工作方式如下：  
1. 将查询得到的辅助索引键值存放于一个缓存中，这时缓存中的数据是根据辅助索引键值排序的。  
2. 将缓存中的键值根据RowID进行排序。  
3. 根据RowID的排序顺序来访问实际的数据文件。  

MRR优化有以下几个好处：  
1. 使得数据访问变得较为顺序。在查询辅助索引时，先对得到的查询结果按照主键进行排序，并按照主键排列的顺序进行书签查找。  
2. 减少缓冲池中页被替换的次数。  
3. 批量处理对键值的查询操作。  

将MRR优化设置为总是开启：  
SET @@optimizer_switch='mrr=on,mrr_cost_based=off';

参数read_rnd_buffer_size用来控制键值的缓冲区大小，当大于该参数值时，执行器根据RowID对已经缓存的数据进行排序，并通过RowID来取得行数据。该值默认为256KB。  

#### Index Condition Pushdown  
mysql5.6开始支持。  
不支持ICP：当进行索引查询时，首先根据索引来查找记录，然后再根据WHERE条件来过滤记录。  
支持ICP：MySQL数据库会在取出索引的同时，判断是否可以进行WHERE条件的过滤（即将WHERE的部分过滤操作放在了存储引擎层）。减少上层SQL层对于记录的索取（fetch）。  

## T树索引  
NDB Cluster内存存储引擎，在使用它时可将其视为内存数据库。内存数据库中，一般使用T树（T-Tree）作为其索引的数据结构。  
NDB Cluster存储引擎中的Order Index（普通索引），使用的就是T树结构。  
T树的好处是节点不存放数据，只存放指针，这样能减少对内存的使用，同时T树也是一棵平衡二叉树，以此保证查找的性能。  
T树节点由3个指针、一个有序数组（array），以及控制信息组成。3个指针分别为指向父节点和左右子树的指针。有序数组保存的是数据指针。  
T树中，对于每个内部节点，存在一个相对应的叶节点或半叶节点存放内部节点的最小值，该值称为最大下界（greatest lowerbound），也存在相对应的叶节点或半叶节点用于存放内部节点的最大值，该值称为最小上界（least upper bound）。  

树的查找和二叉查找树类似，其查找算法为：  
1. 从根节点（root）开始查找，比较节点中最大值和最小值。如果查找的值在边界内，则用二叉法查找T树中的数组。  
2. 若查找的值比根节点的最小值小，则递归查找左子树。  
3. 若查找的值比根节点的最大值大，则递归查找右子树。  
4. 若不存在该值，返回为NULL。  

T树的插入删除旋转操作参见原书9.9部分。  

## 哈希索引  
InnoDB存储引擎使用散列算法来对字典进行查找，其冲突机制采用链表方式，散列函数采用除法散列方式。  

InnoDB存储引擎对于页是怎么进行查找：  
InnoDB存储引擎的表空间都有一个space号，我们要查找的应该是某个表空间的某个连续16KB的页，即偏移量offset。InnoDB存储引擎将space左移20位，然后加上这个space和offset，即关键字K=space << 20 + space +offset，然后通过除法散列到各个槽中去。  

自适应哈希索引采用之前讨论的散列表的方式实现。不同的是，自适应哈希索引仅是数据库自身创建并使用的，DBA本身并不能对其进行干预。自适应哈希索引经散列函数映射到一个散列表中，因此对于字典类型的查找非常快速，例如SELECT ＊ FROM TABLE WHERE index_col='xxx'，但是对于范围查找就无能为力了。通过命令SHOW ENGINE INNODB STATUS可以看到当前自适应哈希索引的使用状况。

[a](#aaa)
